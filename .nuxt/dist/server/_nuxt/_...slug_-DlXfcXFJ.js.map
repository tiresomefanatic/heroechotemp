{"version":3,"file":"_...slug_-DlXfcXFJ.js","sources":["../../../../node_modules/nuxt/dist/app/components/client-only.js","../../../../pages/[...slug].vue"],"sourcesContent":["import { cloneVNode, createElementBlock, createStaticVNode, defineComponent, getCurrentInstance, h, onMounted, provide, ref } from \"vue\";\nimport { isPromise } from \"@vue/shared\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { getFragmentHTML } from \"./utils.js\";\nimport ServerPlaceholder from \"./server-placeholder.js\";\nexport const clientOnlySymbol = Symbol.for(\"nuxt:client-only\");\nexport default defineComponent({\n  name: \"ClientOnly\",\n  inheritAttrs: false,\n  props: [\"fallback\", \"placeholder\", \"placeholderTag\", \"fallbackTag\"],\n  setup(_, { slots, attrs }) {\n    const mounted = ref(false);\n    onMounted(() => {\n      mounted.value = true;\n    });\n    if (import.meta.dev) {\n      const nuxtApp = useNuxtApp();\n      nuxtApp._isNuxtPageUsed = true;\n      nuxtApp._isNuxtLayoutUsed = true;\n    }\n    provide(clientOnlySymbol, true);\n    return (props) => {\n      if (mounted.value) {\n        return slots.default?.();\n      }\n      const slot = slots.fallback || slots.placeholder;\n      if (slot) {\n        return slot();\n      }\n      const fallbackStr = props.fallback || props.placeholder || \"\";\n      const fallbackTag = props.fallbackTag || props.placeholderTag || \"span\";\n      return createElementBlock(fallbackTag, attrs, fallbackStr);\n    };\n  }\n});\nconst cache = /* @__PURE__ */ new WeakMap();\n// @__NO_SIDE_EFFECTS__\nexport function createClientOnly(component) {\n  if (import.meta.server) {\n    return ServerPlaceholder;\n  }\n  if (cache.has(component)) {\n    return cache.get(component);\n  }\n  const clone = { ...component };\n  if (clone.render) {\n    clone.render = (ctx, cache2, $props, $setup, $data, $options) => {\n      if ($setup.mounted$ ?? ctx.mounted$) {\n        const res = component.render?.bind(ctx)(ctx, cache2, $props, $setup, $data, $options);\n        return res.children === null || typeof res.children === \"string\" ? cloneVNode(res) : h(res);\n      } else {\n        const fragment = getFragmentHTML(ctx._.vnode.el ?? null) ?? [\"<div></div>\"];\n        return createStaticVNode(fragment.join(\"\"), fragment.length);\n      }\n    };\n  } else if (clone.template) {\n    clone.template = `\n      <template v-if=\"mounted$\">${component.template}</template>\n      <template v-else><div></div></template>\n    `;\n  }\n  clone.setup = (props, ctx) => {\n    const nuxtApp = useNuxtApp();\n    const mounted$ = ref(nuxtApp.isHydrating === false);\n    const instance = getCurrentInstance();\n    if (nuxtApp.isHydrating) {\n      const attrs = { ...instance.attrs };\n      const directives = extractDirectives(instance);\n      for (const key in attrs) {\n        delete instance.attrs[key];\n      }\n      onMounted(() => {\n        Object.assign(instance.attrs, attrs);\n        instance.vnode.dirs = directives;\n      });\n    }\n    onMounted(() => {\n      mounted$.value = true;\n    });\n    const setupState = component.setup?.(props, ctx) || {};\n    if (isPromise(setupState)) {\n      return Promise.resolve(setupState).then((setupState2) => {\n        if (typeof setupState2 !== \"function\") {\n          setupState2 = setupState2 || {};\n          setupState2.mounted$ = mounted$;\n          return setupState2;\n        }\n        return (...args) => {\n          if (mounted$.value || !nuxtApp.isHydrating) {\n            const res = setupState2(...args);\n            return res.children === null || typeof res.children === \"string\" ? cloneVNode(res) : h(res);\n          } else {\n            const fragment = getFragmentHTML(instance?.vnode.el ?? null) ?? [\"<div></div>\"];\n            return createStaticVNode(fragment.join(\"\"), fragment.length);\n          }\n        };\n      });\n    } else {\n      if (typeof setupState === \"function\") {\n        return (...args) => {\n          if (mounted$.value) {\n            return h(setupState(...args), ctx.attrs);\n          }\n          const fragment = getFragmentHTML(instance?.vnode.el ?? null) ?? [\"<div></div>\"];\n          return createStaticVNode(fragment.join(\"\"), fragment.length);\n        };\n      }\n      return Object.assign(setupState, { mounted$ });\n    }\n  };\n  cache.set(component, clone);\n  return clone;\n}\nfunction extractDirectives(instance) {\n  if (!instance || !instance.vnode.dirs) {\n    return null;\n  }\n  const directives = instance.vnode.dirs;\n  instance.vnode.dirs = null;\n  return directives;\n}\n","# [...slug].vue\n<template>\n  <div class=\"page-wrapper\">\n    <ClientOnly>\n      <div v-if=\"data\">\n        <Header />\n        <div class=\"content-area\" :class=\"{ 'editing-mode': isEditing }\">\n          <!-- Sidebar shown only in non-editing mode -->\n          <aside v-if=\"!isEditing && showSidebar\" class=\"sidebar\">\n            <DesignSidebar />\n          </aside>\n\n          <div\n            class=\"main-content\"\n            :class=\"{ 'with-sidebar': !isEditing && showSidebar }\"\n          >\n            <!-- Content header with edit controls - only show when logged in -->\n            <div v-if=\"isLoggedIn\" class=\"content-header\">\n              <ClientOnly>\n                <button\n                  v-if=\"!isEditing\"\n                  @click=\"handleEditClick\"\n                  class=\"edit-button\"\n                >\n                  Edit\n                </button>\n                <button v-else @click=\"exitEditor\" class=\"edit-button\">\n                  Exit\n                </button>\n              </ClientOnly>\n            </div>\n\n            <!-- Main content area -->\n            <ClientOnly>\n              <div v-if=\"isEditing\" class=\"editor-container\">\n                <TiptapEditor\n                  :content=\"editorContent\"\n                  :filePath=\"contentPath\"\n                  @update:content=\"handleContentChange\"\n                  @save=\"handleSave\"\n                  @error=\"handleEditorError\"\n                />\n              </div>\n              <div v-else class=\"prose-content\">\n                <div :key=\"contentKey\">\n                  <ContentDoc :path=\"path\" :head=\"false\">\n                    <template #empty>\n                      <p>No content found.</p>\n                    </template>\n                    <template #not-found>\n                      <p>Content not found. Path: {{ path }}</p>\n                    </template>\n                  </ContentDoc>\n                </div>\n              </div>\n            </ClientOnly>\n          </div>\n        </div>\n      </div>\n    </ClientOnly>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, watch, onMounted, onBeforeUnmount } from \"vue\";\nimport { useRoute } from \"vue-router\";\nimport { queryContent } from \"#imports\";\nimport { useGithub } from \"~/composables/useGithub\";\nimport { useToast } from \"~/composables/useToast\";\nimport { useAsyncData } from \"#app\";\nimport TiptapEditor from \"~/components/TiptapEditor.vue\";\nimport DesignSidebar from \"~/components/DesignSidebar.vue\";\nimport Header from \"~/components/Header.vue\";\nimport { useRuntimeConfig, useNuxtApp } from \"#app\";\n\n// Initialize GitHub functionality and services\nconst { getRawContent, saveFileContent, isLoggedIn, currentBranch } =\n  useGithub();\nconst { showToast } = useToast();\n\n// State management\nconst loading = ref(false);\nconst isEditing = ref(false);\nconst editorContent = ref(\"\");\nconst contentLastModified = ref<string | null>(null);\n\n// Route handling setup\nconst route = useRoute();\nconst slug = route.params.slug || [];\nconst path = Array.isArray(slug) ? slug.join(\"/\") : slug;\n\n// Compute whether to show sidebar based on path\nconst showSidebar = computed(() => path !== \"\");\nconst contentKey = computed(() => `${path}-${Date.now()}`);\n\n// Content queries for initial page load\nconst { data } = await useAsyncData(\n  `content-${path}`,\n  () => {\n    if (!path) {\n      return queryContent().where({ _path: \"/\" }).findOne();\n    }\n    return queryContent()\n      .where({ _path: `/${path}` })\n      .findOne();\n  },\n  {\n    immediate: true,\n    server: true,\n  }\n);\n\n// Compute the content file path\nconst contentPath = computed(() => {\n  if (!path) return \"content/index.md\";\n  return `content/${path}.md`;\n});\n\n/**\n * Check if content needs to be refreshed by checking latest commit\n */\nconst checkContentFreshness = async () => {\n  try {\n    // Use GitHub API to get latest commit for the file\n    const response = await fetch(\n      `https://api.github.com/repos/tiresomefanatic/heroechotemp/commits?path=${contentPath.value}&sha=${currentBranch.value}`,\n      { headers: { Accept: \"application/vnd.github.v3+json\" } }\n    );\n\n    if (!response.ok) {\n      throw new Error(\"Failed to fetch commit info\");\n    }\n\n    const commits = await response.json();\n    const latestCommitSha = commits[0]?.sha;\n\n    if (latestCommitSha !== contentLastModified.value) {\n      console.log(\"New commit detected, refreshing content...\");\n      contentLastModified.value = latestCommitSha;\n      return true;\n    }\n    return false;\n  } catch (error) {\n    console.error(\"Error checking content freshness:\", error);\n    return true; // Refresh on error to be safe\n  }\n};\n\n/**\n * Loads fresh content from GitHub.\n * This function ensures we always get the latest content by forcing a new fetch\n * and refreshing the local content state.\n */\nconst loadContent = async (force = false) => {\n  loading.value = true;\n  try {\n    const needsRefresh = force || (await checkContentFreshness());\n\n    if (needsRefresh) {\n      console.log(`Fetching fresh content at ${new Date().toISOString()}`);\n      console.log(`Branch: ${currentBranch.value}, Path: ${contentPath.value}`);\n\n      // Get raw content from GitHub\n      const content = await getRawContent(\n        \"tiresomefanatic\",\n        \"heroechotemp\",\n        contentPath.value,\n        currentBranch.value\n      );\n\n      console.log(\"Raw content fetched:\", {\n        length: content?.length || 0,\n        preview: content?.substring(0, 500),\n      });\n\n      // Update editor content\n      editorContent.value = content;\n\n      if (process.client) {\n        // Access Nuxt's content storage directly\n        const nuxtApp = useNuxtApp();\n        const storage = nuxtApp.$content?.storage;\n\n        console.log(\"Current content storage:\", storage);\n\n        // Force Nuxt to clear its content cache\n        if (storage) {\n          await storage.clearAll();\n          console.log(\"Cleared content storage\");\n        }\n\n        // Reload the page content\n        const query = !path\n          ? queryContent().where({ _path: \"/\" })\n          : queryContent().where({ _path: `/${path}` });\n\n        const newData = await query.findOne();\n        console.log(\"New content fetched:\", newData);\n\n        // Update the data reference\n        data.value = newData;\n\n        // Add debug log for final data state\n        console.log(\"Final data state:\", {\n          dataValue: data.value,\n          path: path,\n          contentPath: contentPath.value,\n        });\n      }\n\n      console.log(\"Content loaded and refreshed successfully\");\n    }\n  } catch (error) {\n    console.error(\"Content loading error:\", error);\n    console.error(\"Full error details:\", {\n      name: error.name,\n      message: error.message,\n      stack: error.stack,\n    });\n    showToast({\n      title: \"Error\",\n      message: `Failed to load content from branch: ${currentBranch.value}`,\n      type: \"error\",\n    });\n  } finally {\n    loading.value = false;\n  }\n};\n\n/**\n * Handle visibility change event\n */\nconst handleVisibilityChange = async () => {\n  if (document.visibilityState === \"visible\" && !isEditing.value) {\n    await loadContent();\n  }\n};\n\n/**\n * Handles the edit button click.\n */\nconst handleEditClick = async () => {\n  if (!isLoggedIn.value) {\n    showToast({\n      title: \"Authentication Required\",\n      message: \"Please sign in with GitHub to edit content\",\n      type: \"warning\",\n    });\n    return;\n  }\n\n  isEditing.value = true;\n  await loadContent(true);\n};\n\nconst handleContentChange = (newContent: string) => {\n  editorContent.value = newContent;\n};\n\n/**\n * Handles saving content to GitHub.\n */\nconst handleSave = async (content: string) => {\n  if (!content || !isLoggedIn.value) {\n    showToast({\n      title: \"Error\",\n      message: \"Please sign in to save changes\",\n      type: \"error\",\n    });\n    return;\n  }\n\n  try {\n    console.log(`Saving content to branch: ${currentBranch.value}`);\n    const result = await saveFileContent(\n      \"tiresomefanatic\",\n      \"heroechotemp\",\n      contentPath.value,\n      content,\n      `Update ${contentPath.value}`,\n      currentBranch.value\n    );\n\n    if (result) {\n      showToast({\n        title: \"Success\",\n        message: `Content saved successfully to branch: ${currentBranch.value}`,\n        type: \"success\",\n      });\n\n      await loadContent(true);\n      isEditing.value = false;\n    } else {\n      throw new Error(`Failed to save to branch: ${currentBranch.value}`);\n    }\n  } catch (error) {\n    console.error(`Error saving content:`, error);\n    showToast({\n      title: \"Error\",\n      message: `Failed to save to branch: ${currentBranch.value}`,\n      type: \"error\",\n    });\n  }\n};\n\nconst handleEditorError = (error: Error) => {\n  showToast({\n    title: \"Editor Error\",\n    message: error.message,\n    type: \"error\",\n  });\n};\n\nconst exitEditor = async () => {\n  await loadContent(true);\n  isEditing.value = false;\n};\n\n// Watch for editing mode changes\nwatch(isEditing, async (newValue, oldValue) => {\n  if (newValue && !oldValue) {\n    await loadContent(true);\n  }\n});\n\n// Watch for branch changes\nwatch(currentBranch, async (newBranch, oldBranch) => {\n  if (newBranch !== oldBranch) {\n    console.log(\n      `Branch changed from ${oldBranch} to ${newBranch}, reloading content...`\n    );\n    await loadContent(true);\n  }\n});\n\n// Watch for path changes\nwatch(contentPath, async (newPath, oldPath) => {\n  if (newPath !== oldPath) {\n    await loadContent(true);\n  }\n});\n\n// Setup content refresh and event handlers only on client side\nonMounted(() => {\n  if (process.client) {\n    // Initial content load\n    loadContent(true);\n\n    // Setup visibility change handler\n    document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n\n    // Setup polling only on client side\n    const contentRefreshInterval = setInterval(async () => {\n      if (!isEditing.value) {\n        await loadContent();\n      }\n    }, 30000);\n\n    // Cleanup function\n    onBeforeUnmount(() => {\n      clearInterval(contentRefreshInterval);\n      document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n    });\n  }\n});\n</script>\n\n<style>\n/* Global prose styles */\n.prose-content {\n  max-width: 100%;\n  width: 100%;\n  margin: 0;\n  color: #000000;\n  font-size: 16px;\n  line-height: 1.6;\n}\n\n.prose-content h1 {\n  font-size: 2em;\n  margin: 1.2em 0 0.6em;\n  font-weight: 600;\n  line-height: 1.2;\n  color: #000000;\n}\n\n.prose-content h2 {\n  font-size: 1.5em;\n  margin: 1em 0 0.5em;\n  font-weight: 600;\n  line-height: 1.3;\n  color: #000000;\n}\n\n.prose-content h3 {\n  font-size: 1.25em;\n  margin: 0.8em 0 0.4em;\n  font-weight: 600;\n  line-height: 1.4;\n  color: #000000;\n}\n\n.prose-content p {\n  margin: 1em 0;\n  color: #000000;\n}\n\n.prose-content ul,\n.prose-content ol {\n  margin: 1em 0;\n  padding-left: 1.5em;\n  color: #000000;\n}\n\n.prose-content li {\n  margin: 0.5em 0;\n}\n\n.prose-content a {\n  color: #4361ee;\n  text-decoration: underline;\n}\n\n.prose-content blockquote {\n  border-left: 4px solid #e5e7eb;\n  margin: 1.5em 0;\n  padding-left: 1em;\n  color: #4b5563;\n}\n\n.prose-content code {\n  background: #f3f4f6;\n  padding: 0.2em 0.4em;\n  border-radius: 4px;\n  font-size: 0.9em;\n  font-family: ui-monospace, monospace;\n}\n\n.prose-content pre {\n  background: #f3f4f6;\n  padding: 1em;\n  border-radius: 6px;\n  overflow-x: auto;\n  margin: 1.5em 0;\n}\n\n.prose-content pre code {\n  background: none;\n  padding: 0;\n  font-size: 0.9em;\n  color: #000000;\n}\n\n.prose-content img {\n  max-width: 100%;\n  height: auto;\n  margin: 1.5em 0;\n}\n\n.prose-content hr {\n  border: 0;\n  border-top: 1px solid #e5e7eb;\n  margin: 2em 0;\n}\n</style>\n\n<style scoped>\n.page-wrapper {\n  min-height: 100vh;\n  position: relative;\n}\n\n.content-area {\n  display: flex;\n  background: white;\n  min-height: calc(100vh - 64px);\n}\n\n.content-area.editing-mode {\n  padding: 32px;\n}\n\n.sidebar {\n  width: 240px;\n  flex-shrink: 0;\n  border-right: 1px solid #e5e7eb;\n  background: white;\n}\n\n.main-content {\n  flex: 1;\n  max-width: 100%;\n  padding: 0;\n}\n\n.main-content.with-sidebar {\n  padding: 0;\n}\n\n.content-header {\n  padding: 24px 32px;\n  display: flex;\n  justify-content: flex-end;\n  background: white;\n  border-bottom: 1px solid #e5e7eb;\n}\n\n.edit-button {\n  padding: 8px 16px;\n  background: #4361ee;\n  color: white;\n  border: none;\n  border-radius: 6px;\n  cursor: pointer;\n  font-size: 14px;\n  transition: background-color 0.2s ease;\n}\n\n.edit-button:hover {\n  background: #3651d4;\n}\n\n.editor-container {\n  background: white;\n  border-radius: 8px;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\n  min-height: calc(100vh - 200px);\n  margin: 0;\n}\n</style>\n"],"names":["_withAsyncContext"],"mappings":"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","x_google_ignoreList":[0]}